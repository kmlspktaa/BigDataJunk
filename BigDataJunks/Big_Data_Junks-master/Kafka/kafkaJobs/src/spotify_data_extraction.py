# -*- coding: utf-8 -*-
"""spotify_data_extraction_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IGsQnXmb-n-KrgqNtabjWiYb_67LnyJb
"""


import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

cid ='fda982ead35c41c2b8b3e2763e7a0304'
secret = '7de8b0a3d1ca447f8db9d509ce8e5f1d'

client_credentials_manager = SpotifyClientCredentials(client_id=cid, client_secret=secret)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

# timeit library to measure the time needed to run this code
import timeit
start = timeit.default_timer()

# create empty lists where the results are going to be stored
artist_name = []
track_name = []
popularity = []
track_id = []
year = []
y_start = 2020  #Year Start
y_end = 2021  #Year End

for y in range(y_start,y_end,1):
  for i in range(0,2000,50):
      name = 'Define artist name' #Popularity by artist name

      track_results = sp.search('year:'+ str(y), type='track',limit=50,offset=i)
      for i, t in enumerate(track_results['tracks']['items']):
          artist_name.append(t['artists'][0]['name'])
          track_name.append(t['name'])
          track_id.append(t['id'])
          popularity.append(t['popularity'])
          year.append(y)
      

stop = timeit.default_timer()
print ('Time to run this code (in seconds):', stop - start)

print('number of elements in the track_id list:', len(track_id))

import pandas as pd

df_tracks = pd.DataFrame({'artist_name':artist_name,'track_name':track_name,'track_id':track_id,'popularity':popularity,'year':year})
print(df_tracks.shape)
df_tracks.head()

df_tracks.info()

# group the entries by artist_name and track_name and check for duplicates

grouped = df_tracks.groupby(['artist_name','track_name'], as_index=True).size()
grouped[grouped > 1].count()

df_tracks.drop_duplicates(subset=['artist_name','track_name'], inplace=True)

# doing the same grouping as before to verify the solution
grouped_after_dropping = df_tracks.groupby(['artist_name','track_name'], as_index=True).size()
grouped_after_dropping[grouped_after_dropping > 1].count()

df_tracks[df_tracks.duplicated(subset=['artist_name','track_name'],keep=False)].count()

df_tracks.shape

# again measuring the time
start = timeit.default_timer()

# empty list, batchsize and the counter for None results
rows = []
batchsize = 100
None_counter = 0

for i in range(0,len(df_tracks['track_id']),batchsize):
    batch = df_tracks['track_id'][i:i+batchsize]
    feature_results = sp.audio_features(batch)
    for i, t in enumerate(feature_results):
        if t == None:
            None_counter = None_counter + 1
        else:
            rows.append(t)
            
print('Number of tracks where no audio features were available:',None_counter)

stop = timeit.default_timer()
print ('Time to run this code (in seconds):',stop - start)

print('number of elements in the track_id list:', len(rows))

df_audio_features = pd.DataFrame.from_dict(rows,orient='columns')
print("Shape of the dataset:", df_audio_features.shape)
df_audio_features.head()

df_audio_features.info()

#columns_to_drop = ['analysis_url','track_href','type','uri']
#df_audio_features.drop(columns_to_drop, axis=1,inplace=True)

df_audio_features.rename(columns={'id': 'track_id'}, inplace=True)

df_audio_features.shape

# merge both dataframes
# the 'inner' method will make sure that we only keep track IDs present in both datasets
df = pd.merge(df_tracks,df_audio_features,on='track_id',how='inner')
print("Shape of the dataset:", df_audio_features.shape)
df.head()

df.info()

df[df.duplicated(subset=['artist_name','track_name'],keep=False)]

df.to_csv('/home/fieldemployee/bin/Spotify.csv')